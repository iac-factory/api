import Utility from "util";

/*Provider bindings are generated by running cdktf get.
 See https://cdk.tf/provider-generation for more details.*/
import * as aws from "@cdktf/provider-aws";
import * as docker from "@cdktf/provider-docker";
import { Construct } from "constructs";
import { App, TerraformStack } from "cdktf";

const organization = "test";
const region: string = "us-east-2";
// const baseDomain = "cloud-factory.io";
const service = "service";
const environment = "Development";
// const subdomain = "iac-api";
const application = "test";

const alias = [ organization, environment, service ].join( "-" );
// const domain = [ subdomain, environment ].join( "." );

// const elbAccountIdentifiers = {
//     caCentral: "985666609251",
//     usEast1: "127311923021",
//     usEast2: "033677994240",
//     usWest1: "027434742980",
//     usWest2: "797873946194"
// };

// const files = [
//     "${[ for file in fileset( join(\"/\", [ path.root, \"artifacts\" ]), \"**/*\") : file ]}"
// ];
// const fqdn = [ domain, baseDomain ].join( "." );
// const name = [ organization, environment, application, service ].join( "-" );
// const s3LogDirectory = "AWSLogs";
// const s3Partition = "arn:${data.aws_partition.configuration.partition}:s3::";
const publicSubnets = [
    "172.168.100.0/24",
    "172.168.101.0/24",
    "172.168.102.0/24"
];
const zones = ( region == "us-east-1" ) ? [ "a", "b", "c", "d", "e", "f" ].map( (assignment) => [ region, assignment ].join( "" ) ) : [ "a", "b", "c" ].map( (assignment) => [ region, assignment ].join( "" ) );

class MyStack extends TerraformStack {
    constructor(scope: Construct, name: string = [ organization, environment, application, service ].join( "-" )) {
        super( scope, name );

        new docker.DockerProvider( this, "docker", {
            host: "unix:///var/run/docker.sock"
        } );

        new aws.AwsProvider( this, "aws-default-provider", {
            profile: "default",
            region: region,
            sharedConfigFiles: [ "~/.aws/config" ],
            sharedCredentialsFiles: [ "~/.aws/credentials" ]
        } );

        const identity = new aws.datasources.DataAwsCallerIdentity( this, "aws-caller-identity", {} );

        const CWLogGroupName = Utility.format( "%s-Log-Group", name );
        const awsCloudwatchLogGroupLogGroup = new aws.cloudwatch.CloudwatchLogGroup(
            this,
            "log-group",
            {
                name: CWLogGroupName,
                retentionInDays: 14
            }
        );
        const awsEcrRepositoryRegistry = new aws.ecr.EcrRepository( this, "registry", {
            encryptionConfiguration: [
                {
                    encryptionType: "AES256"
                }
            ],
            imageScanningConfiguration: {
                scanOnPush: true
            },
            imageTagMutability: "MUTABLE",
            name: name.toLowerCase()
        } );
        const awsEcsAccountSettingDefaultAccountSettings =
            new aws.ecs.EcsAccountSettingDefault( this, "account-settings", {
                name: "containerInsights",
                value: "enabled"
            } );
        const awsEcsClusterCluster = new aws.ecs.EcsCluster( this, "cluster", {
            name: Utility.format( "%s-Cluster", name ),
            setting: [
                {
                    name: "containerInsights",
                    value: awsEcsAccountSettingDefaultAccountSettings.value
                }
            ]
        } );
        const awsS3BucketalbLoggingBucket = new aws.s3.S3Bucket(
            this,
            "application-load-balancer-logging-bucket",
            {
                bucket: Utility.format( "%s-ALB-Logging", name ).toLowerCase()
            }
        );
        new aws.s3.S3Bucket( this, "logging-bucket", {
            bucket: Utility.format( "%s-Logging", name ).toLowerCase()
        } );
        new aws.s3.S3BucketAcl( this, "application-load-balancer-logging-bucket-acl", {
            acl: "log-delivery-write",
            bucket: awsS3BucketalbLoggingBucket.bucket
        } );
        new aws.s3.S3BucketAcl( this, "primary-bucket-acl", {
            acl: "log-delivery-write",
            bucket: awsS3BucketalbLoggingBucket.bucket
        } );
        const awsVpcVpc = new aws.vpc.Vpc( this, "vpc", {
            assignGeneratedIpv6CidrBlock: true,
            cidrBlock: "10.0.0.0/16",
            enableDnsHostnames: false,
            enableDnsSupport: true,
            tags: {
                name: Utility.format( "%s-VPC", name )
            }
        } );

        new aws.datasources.DataAwsAvailabilityZones( this, "available", {
            state: "available"
        } );

        new aws.ecr.DataAwsEcrImage( this, "image", {
            imageTag: "latest",
            registryId: awsEcrRepositoryRegistry.registryId,
            repositoryName: awsEcrRepositoryRegistry.name
        } );

        const dataAwsIamPolicyDocumentalbLoggingBucketPolicy =
            new aws.iam.DataAwsIamPolicyDocument(
                this,
                "application-load-balancer-logging-bucket-policy",
                {
                    statement: [
                        {
                            actions: [
                                "s3:ListBucket",
                                "s3:PutObject",
                                "s3:DeleteObjectTagging",
                                "s3:DeleteObjectVersion",
                                "s3:DeleteObjectVersionTagging",
                                "s3:GetObjectAcl",
                                "s3:GetObjectAttributes",
                                "s3:GetObjectRetention",
                                "s3:GetObjectTagging",
                                "s3:GetObjectTorrent",
                                "s3:GetObjectVersion",
                                "s3:GetObjectVersionAcl",
                                "s3:GetObjectVersionAttributes",
                                "s3:GetObjectVersionForReplication",
                                "s3:GetObjectVersionTagging",
                                "s3:GetObjectVersionTorrent",
                                "s3:InitiateReplication",
                                "s3:ListMultipartUploadParts",
                                "s3:PutObject",
                                "s3:PutObjectAcl",
                                "s3:PutObjectRetention",
                                "s3:PutObjectTagging",
                                "s3:PutObjectVersionAcl",
                                "s3:PutObjectVersionTagging",
                                "s3:PutReplicationConfiguration",
                                "s3:ReplicateDelete",
                                "s3:ReplicateObject",
                                "s3:ReplicateTags",
                                "s3:RestoreObject"
                            ],
                            condition: [
                                {
                                    test: "StringEquals",
                                    values: [
                                        "033677994240",
                                        identity.accountId
                                    ],
                                    variable: "aws:SourceAccount"
                                },
                                {
                                    test: "StringEquals",
                                    values: [ "bucket-owner-full-control" ],
                                    variable: "s3:x-amz-acl"
                                }
                            ],
                            effect: "Allow",
                            resources: [
                                awsS3BucketalbLoggingBucket.arn,
                                Utility.format( "%s/*", awsS3BucketalbLoggingBucket.arn )
                            ]
                        }
                    ]
                }
            );
        new aws.iam.DataAwsIamPolicyDocument( this, "ecs-agent-assume-role-policy", {
            statement: [
                {
                    actions: [ "sts:AssumeRole" ],
                    principals: [
                        {
                            identifiers: [ "ec2.amazonaws.com" ],
                            type: "Service"
                        }
                    ]
                }
            ]
        } );
        const dataAwsIamPolicyDocumentEcsTasksAssumeRolePolicy =
            new aws.iam.DataAwsIamPolicyDocument( this, "ecs-tasks-assume-role-policy", {
                statement: [
                    {
                        actions: [ "sts:AssumeRole" ],
                        principals: [
                            {
                                identifiers: [ "ecs-tasks.amazonaws.com" ],
                                type: "Service"
                            }
                        ]
                    }
                ]
            } );

        new aws.iam.IamPolicy( this, "alb-logging-s3-policy", {
            name: Utility.format( "%s-Application-Load-Balancer-S3-Logging-Policy", name ),
            policy:
            dataAwsIamPolicyDocumentalbLoggingBucketPolicy.json
        } );
        const awsIamRoleEcsTaskExecutionRole = new aws.iam.IamRole(
            this,
            "ecs-task-execution-role",
            {
                assumeRolePolicy: dataAwsIamPolicyDocumentEcsTasksAssumeRolePolicy.json,
                name: Utility.format( "%s-ECS-Execution-Task-Role", name )
            }
        );
        const awsIamRoleEcsTaskRuntimeRole = new aws.iam.IamRole(
            this,
            "ecs-task-runtime-role",
            {
                assumeRolePolicy: dataAwsIamPolicyDocumentEcsTasksAssumeRolePolicy.json,
                name: Utility.format( "%s-ECS-Runtime-Task-Role", name )
            }
        );

        const secretsManagerPolicy = new aws.iam.IamPolicy( this, "secrets-manager-policy", {
            name: Utility.format( "%s-SSM-Secrets-IAM-Policy", name ),
            path: "/",
            policy: JSON.stringify(
                {
                    Version: "2012-10-17",
                    Statement: [
                        {
                            Effect: "Allow",
                            Action: [
                                "secretsmanager:GetSecretValue",
                                "ssm:GetParameters"
                            ]
                        } ],
                    Resource: [
                        [ "arn", "aws", "secretsmanager", region, identity.accountId, "secret", "*" ].join( ":" ),
                        [ "arn", "aws", "ssm", region, identity.accountId, "parameter" ].join( ":" ) + "/*"
                    ]
                }, null, 4 )
        } );

        new aws.iam.IamRolePolicy( this, "runtime-policy", {
            name: Utility.format( "%s-ECS-Runtime-Task-Role-Policy", name ),
            policy: secretsManagerPolicy.policy,
            role: awsIamRoleEcsTaskRuntimeRole.name
        } );

        new aws.iam.IamRolePolicyAttachment(
            this,
            "ecs-task-execution-policy-attachment",
            {
                policyArn:
                    "arn:aws:iam::aws:policy/service-role/AmazonEC2ContainerServiceforEC2Role",
                role: awsIamRoleEcsTaskExecutionRole.name
            }
        );
        const awsInternetGatewayIgw = new aws.vpc.InternetGateway( this, "igw", {
            tags: {
                Name: Utility.format( "%s-IGW" )
            },
            vpcId: awsVpcVpc.id
        } );
        const albTargetGroupalbHttpTargetGroup =
            new aws.elb.LbTargetGroup(
                this,
                "application-load-balancer-http-target-group",
                {
                    deregistrationDelay: "0",
                    healthCheck: {
                        enabled: true,
                        healthyThreshold: 3,
                        interval: 300,
                        matcher: "200",
                        path: "/",
                        port: "traffic-port",
                        protocol: "HTTP",
                        timeout: 3,
                        unhealthyThreshold: 3
                    },
                    lambdaMultiValueHeadersEnabled: false,
                    loadBalancingAlgorithmType: "round_robin",
                    name: Utility.format( "%s-TG", alias ),
                    port: 80,
                    protocol: "HTTP",
                    stickiness: {
                        cookieDuration: 86400,
                        cookieName: Utility.format( "X-%s-ALB-Cookie", name ),
                        enabled: true,
                        type: "app_cookie"
                    },
                    tags: {
                        name: Utility.format( "%s-ALB-HTTP-TG", name )
                    },
                    targetType: "ip",
                    vpcId: awsVpcVpc.id
                }
            );

        const awsRouteTablePublicRoutingTable = new aws.vpc.RouteTable( this, "public-routing-table", {
            tags: { name: Utility.format( "%s-Public-Routing-Table", name ) },
            vpcId: awsVpcVpc.id
        } );

        new aws.s3.S3BucketPolicy( this, "application-load-balancer-logging-policy", {
            bucket: awsS3BucketalbLoggingBucket.id,
            policy: JSON.stringify( {
                Version: "2012-10-17",
                Statement: [
                    {
                        Effect: "Allow",
                        Principal: {
                            Service: "delivery.logs.amazonaws.com"
                        },
                        Action: "s3:PutObject",
                        Resource: [ "arn:aws:s3:::", awsS3BucketalbLoggingBucket.bucket, "/load-balancer/AWSLogs/", identity.accountId, "/*" ].join( "" ),
                        Condition: {
                            StringEquals: {
                                "s3:x-amz-acl": "bucket-owner-full-control"
                            }
                        }
                    },
                    {
                        Effect: "Allow",
                        Principal: {
                            Service: "delivery.logs.amazonaws.com"
                        },
                        Action: "s3:GetBucketAcl",
                        Resource: [ "arn:aws:s3:::", awsS3BucketalbLoggingBucket.bucket ].join( "" )
                    }
                ]
            }, null, 4 )
        } );

        const awsSecurityGroupalbHttpSecurityGroup =
            new aws.vpc.SecurityGroup(
                this,
                "application-load-balancer-http-security-group",
                {
                    description: "ECS Application Load Balancer HTTP Traffic Security Group",
                    egress: [
                        {
                            cidrBlocks: [ "0.0.0.0/0" ],
                            fromPort: 0,
                            ipv6CidrBlocks: [ "::/0" ],
                            protocol: "-1",
                            toPort: 0
                        }
                    ],
                    ingress: [
                        {
                            cidrBlocks: [ "0.0.0.0/0" ],
                            fromPort: 80,
                            ipv6CidrBlocks: [ "::/0" ],
                            protocol: "tcp",
                            toPort: 80
                        },
                        {
                            cidrBlocks: [ "0.0.0.0/0" ],
                            fromPort: 443,
                            ipv6CidrBlocks: [ "::/0" ],
                            protocol: "tcp",
                            toPort: 443
                        }
                    ],
                    name: Utility.format( "%s-ALB-HTTP-SG", name ),
                    tags: {
                        Name: Utility.format( "%s-ALB-HTTP-SG", name )
                    },
                    vpcId: awsVpcVpc.id
                }
            );

        const awsSecurityGroupEcsClusterServicePrivateSecurityGroup =
            new aws.vpc.SecurityGroup(
                this,
                "ecs-cluster-service-private-security-group",
                {
                    name: Utility.format( "%s-ALB-HTTPs-SG", name ),
                    description: "Egress + Ingress ALB to ECS Cluster",
                    egress: [
                        {
                            cidrBlocks: [ "0.0.0.0/0" ],
                            fromPort: 0,
                            ipv6CidrBlocks: [ "::/0" ],
                            protocol: "-1",
                            toPort: 0
                        }
                    ],
                    ingress: [
                        {
                            cidrBlocks: [ "0.0.0.0/0" ],
                            fromPort: 80,
                            ipv6CidrBlocks: [ "::/0" ],
                            protocol: "tcp",
                            toPort: 80
                        },
                        {
                            cidrBlocks: publicSubnets,
                            fromPort: 8080,
                            ipv6CidrBlocks: [],
                            protocol: "tcp",
                            toPort: 8080
                        },
                        {
                            cidrBlocks: [ "0.0.0.0/0" ],
                            fromPort: 443,
                            ipv6CidrBlocks: [ "::/0" ],
                            protocol: "tcp",
                            toPort: 443
                        }
                    ],
                    tags: {
                        Name: Utility.format( "%s-ALB-HTTPs-SG", name )
                    },
                    vpcId: awsVpcVpc.id
                }
            );

        publicSubnets.forEach( (element, index) => {
            const subnet = new aws.vpc.Subnet( this, [ "public-subnet", index ].join( "-" ), {
                assignIpv6AddressOnCreation: true,
                availabilityZone: zones[ index ],
                cidrBlock: element,
                mapPublicIpOnLaunch: true,
                tags: {
                    name: Utility.format( "%s-Public-Subnet-%s", name, index )
                },
                vpcId: awsVpcVpc.id
            } );

            new aws.vpc.RouteTableAssociation( this, [ "public-routing-association", index ].join( "-" ), {
                routeTableId: awsRouteTablePublicRoutingTable.id,
                subnetId: subnet.id
            } );
        } );

        const awsVpcDhcpOptionsDhcpOptionsSet = new aws.vpc.VpcDhcpOptions(
            this,
            "dhcp-options-set",
            {
                domainName: Utility.format( "%s.compute.internal", region ),
                domainNameServers: [ "AmazonProvidedDNS" ],
                tags: {
                    Name: Utility.format( "%s-DHCP", name )
                }
            }
        );
        new aws.vpc.VpcDhcpOptionsAssociation( this, "dns-resolver", {
            dhcpOptionsId: awsVpcDhcpOptionsDhcpOptionsSet.id,
            vpcId: awsVpcVpc.id
        } );

        const awsAlbalb = new aws.elb.Alb(
            this,
            "application-load-balancer",
            {
                accessLogs: {
                    bucket: awsS3BucketalbLoggingBucket.id,
                    enabled: false,
                    prefix: "load-balancer"
                },
                desyncMitigationMode: "defensive",
                dropInvalidHeaderFields: false,
                enableCrossZoneLoadBalancing: false,
                enableDeletionProtection: false,
                enableHttp2: true,
                enableWafFailOpen: false,
                internal: false,
                loadBalancerType: "application",
                name: Utility.format( "%s", "0e1ce440-7f79-48ae-8a6f-db83ca52" ),
                securityGroups: [
                    awsSecurityGroupalbHttpSecurityGroup.id
                ],
                subnets: publicSubnets,
                tags: {
                    Name: Utility.format( "%s-ALB", name )
                }
            }
        );
        new aws.iam.IamInstanceProfile( this, "ecs-task-execution-instance-profile", {
            name: Utility.format( "%s-Execution-Task-Instance-Profile", name ),
            role: awsIamRoleEcsTaskExecutionRole.name
        } );

        new aws.elb.LbListener( this, "alb-listener", {
            defaultAction: [
                {
                    targetGroupArn:
                    albTargetGroupalbHttpTargetGroup.id,
                    type: "forward"
                }
            ],
            loadBalancerArn: awsAlbalb.id,
            port: 80,
            protocol: "HTTP"
        } );

        new aws.vpc.Route( this, "igw-route", {
            destinationCidrBlock: "0.0.0.0/0",
            gatewayId: awsInternetGatewayIgw.id,
            routeTableId: awsRouteTablePublicRoutingTable.id
        } );

        new aws.accessanalyzer.AccessanalyzerAnalyzer( this, "access-analysis", {
            analyzerName: Utility.format( "%s-Access-Analysis", name ),
            type: "ACCOUNT"
        } );

        new docker.Image( this, "ecs-cluster-docker-image", {
            name: Utility.format( "%s-Container", name ).toLowerCase(),
            buildAttribute: {
                tag: [
                    "repository"
                ],
                noCache: true,
                remove: true,
                forceRemove: true,
                path: "./artifacts"
            },
            keepLocally: false,
            forceRemove: true
        } );

        const awsEcsTaskDefinitionTaskDefinition = new aws.ecs.EcsTaskDefinition(
            this,
            "ecs-cluster-task-definition",
            {
                requiresCompatibilities: [ "FARGATE" ],
                networkMode: "awsvpc",
                containerDefinitions: JSON.stringify( [ {
                    "name": "test",
                    "image": "nginx",
                    "essential": true,
                    "cpu": 256,
                    "memory": 512,
                    "links": [],
                    "entryPoint": [],
                    "portMappings": [
                        {
                            "containerPort": 8080
                        }
                    ],
                    "logConfiguration": {
                        "logDriver": "awslogs",
                        "options": {
                            "awslogs-region": region,
                            "awslogs-group": CWLogGroupName,
                            "awslogs-stream-prefix": "ecs-service",
                            "mode": "non-blocking",
                            "max-buffer-size": "1m"
                        }
                    }
                } ] ),
                // dependsOn: [ `\${${ dockerImageImage.fqn }}` ],
                executionRoleArn: awsIamRoleEcsTaskExecutionRole.arn,
                family: "service",
                taskRoleArn: awsIamRoleEcsTaskExecutionRole.arn,
                dependsOn: [
                    awsCloudwatchLogGroupLogGroup
                ]
            }
        );

        new aws.ecs.DataAwsEcsTaskDefinition( this, "ecs-cluster-service-primary-task-definition", {
            taskDefinition: awsEcsTaskDefinitionTaskDefinition.family
        } );

        new aws.ecs.EcsService( this, "ecs-cluster-service", {
            cluster: awsEcsClusterCluster.id,
            deploymentCircuitBreaker: {
                enable: true,
                rollback: true
            },
            deploymentController: {
                type: "ECS"
            },
            deploymentMaximumPercent: 200,
            deploymentMinimumHealthyPercent: 100,
            desiredCount: 3,
            enableEcsManagedTags: true,
            forceNewDeployment: true,
            healthCheckGracePeriodSeconds: 180,
            launchType: "FARGATE",
            loadBalancer: [
                {
                    containerName: "test",
                    containerPort: 8080,
                    targetGroupArn:
                    albTargetGroupalbHttpTargetGroup.arn
                }
            ],
            name: Utility.format( "%s-HTTP-API-Service", name ),
            networkConfiguration: {
                assignPublicIp: true,
                securityGroups: [
                    awsSecurityGroupEcsClusterServicePrivateSecurityGroup.id,
                    awsSecurityGroupalbHttpSecurityGroup.id
                ],
                subnets: publicSubnets
            },
            platformVersion: "LATEST",
            propagateTags: "SERVICE",
            schedulingStrategy: "REPLICA",
            taskDefinition: awsEcsTaskDefinitionTaskDefinition.arn
        } );
    }
}

const app = new App();
new MyStack( app );
app.synth();
